% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partition_neighbour.R
\name{partition.neighbour}
\alias{partition.neighbour}
\alias{partition.random.neighbour}
\alias{partition.all.neighbour}
\alias{partition.all.neighbour.restricted}
\title{Generate neighbours of a graycode with or withour pre-specified restrictions}
\usage{
partition.random.neighbour(x, method = "ChangeOne", IncludeOrigin = FALSE)

partition.all.neighbour(x, method = "ChangeOne", IncludeOrigin = FALSE)

partition.all.neighbour.restricted(x, group = NULL, apart = NULL,
  method = "ChangeOne", IncludeOrigin = FALSE)
}
\arguments{
\item{x}{a numerical vector representing a graycode}

\item{method}{which method used to generate neighbours; either \code{"ChangeOne"} or \code{"GroupSplit"}}

\item{IncludeOrigin}{logical; indicating whether the input graycode should be included}

\item{group}{a vector indicating which elements should be grouped together}

\item{apart}{a vector indicating which elements should not be grouped together}
}
\value{
a random neighbouring partition or a matrix of all neighbouring partitions
}
\description{
This algorithm randomly pick two groups and put them together, or randomly pick one group and split it into 2 groups, only generate one random neighbour each time
}
\examples{
partition.random.neighbour(x = c(1,2,3,1), IncludeOrigin = F) # "ChangeOne" method by default
partition.all.neighbour(x = c(1,2,3,1), IncludeOrigin = F)

partition.random.neighbour(c(1,2,3,4,2,4,1), method="GroupSplit", IncludeOrigin = F)
partition.all.neighbour(c(1,2,2,3,3,3,3), method="GroupSplit", IncludeOrigin = F)

# the following example shows the distribution of generating random partition is not uniform
x <- c(1,2,2,2,3,3,3)
allneighbour <- NULL
for (j in c(1:1000)){
  oneneighbour <- partition.random.neighbour.GroupSplit(x)
  allneighbour <- rbind(allneighbour, oneneighbour)
}
dim(allneighbour)
uniquecode <- unique(allneighbour)
dim(uniquecode)
dim(partition.all.neighbour(x, method="GroupSplit"))
count1<-count2<-count3<-count4<-count5<-count6<-count7<-count8<-count9<-0
for (i in c(1: dim(allneighbour)[1])){
  if (all(uniquecode[1,] == allneighbour[i,])) count1 <- count1 + 1
  if (all(uniquecode[2,] == allneighbour[i,])) count2 <- count2 + 1
  if (all(uniquecode[3,] == allneighbour[i,])) count3 <- count3 + 1
  if (all(uniquecode[4,] == allneighbour[i,])) count4 <- count4 + 1
  if (all(uniquecode[5,] == allneighbour[i,])) count5 <- count5 + 1
  if (all(uniquecode[6,] == allneighbour[i,])) count6 <- count6 + 1
  if (all(uniquecode[7,] == allneighbour[i,])) count7 <- count7 + 1
  if (all(uniquecode[8,] == allneighbour[i,])) count8 <- count8 + 1
  if (all(uniquecode[9,] == allneighbour[i,])) count9 <- count9 + 1
}
c(count1, count2, count3, count4, count5, count6, count7, count8, count9)

partition.all.neighbour.restricted(x = c(1,2,3,1),
                                   group=NULL,
                                   apart=c(2,3),
                                   IncludeOrigin = T)
partition.all.neighbour.restricted(x=c(1,2,3,1),
                                   group = c(2,3),
                                   apart = NULL,
                                   IncludeOrigin = T)
partition.all.neighbour.restricted(x=c(1,2,3,1),
                                   IncludeOrigin = T)

}
\references{
Hu, S., O'Hagan, A. and Murphy, T. B. (2007). Motor Insurance Accidental Damage Claims Modelling with Factor Collapsing and Bayesian model Averaging
}
\author{
Sen Hu
}
